%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,a4paper,titlepage]{article}



\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}

%\usepackage{fouriernc}
%\usepackage{pxfonts}
\usepackage[charter]{mathdesign}
\usepackage[no-math]{fontspec}
%\usepackage{polyglossia}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{graphicx}
\usepackage{xltxtra}
\usepackage{makeidx}
\usepackage{enumerate}
\usepackage{caption}
%\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage[hidelinks]{hyperref}
\usepackage{grffile}
\usepackage{adjustbox}
\usepackage{dirtree}
\usepackage{xfrac}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{tikzscale}
\usetikzlibrary{plotmarks}


\setmainfont[
UprightFont = *,
ItalicFont = *Italics,
SlantedFont = *Italics,
BoldFont = *sb,
BoldItalicFont = *sbi,
BoldSlantedFont = *sbi,
SmallCapsFont = *SmallCaps
]{Kerkis}

\newfontfamily{\greekfont}[
UprightFont = *,
ItalicFont = *Italics,
SlantedFont = *Italics,
BoldFont = *sb,
BoldItalicFont = *sbi,
BoldSlantedFont = *sbi,
SmallCapsFont = *SmallCaps
]{Kerkis}



% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.15in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{} % Top left header
\chead{\hmwkClass\ - \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Σελίδα\ \thepage\ από\ \pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

\setcounter{secnumdepth}{0}
\setcounter{tocdepth}{1}

\DTsetlength{0.3em}{1.2em}{0.2em}{0.4pt}{0pt}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}

%----------------------------------------------------------------------------------------
%	LOCALIZATION
%----------------------------------------------------------------------------------------

\renewcommand\figurename{Σχήμα}
\renewcommand\contentsname{Περιεχόμενα}
\renewcommand\indexname{Ευρετήριο}
\renewcommand\tablename{Πίνακας}
\renewcommand\appendixname{Παράρτημα}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Εργασία 4} % Assignment title
\newcommand{\hmwkClass}{Παράλληλα \& Διανεμημένα Συστήματα} % Course/class
\newcommand{\hmwkAuthorName}{Δημανίδης Ιωάννης} % Your name
\newcommand{\hmwkAuthorAEM}{8358} % Your ΑΕΜ

%----------------------------------------------------------------------------------------
%	MISC OPTIONS
%----------------------------------------------------------------------------------------

\graphicspath{{./figures/}}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\makeatletter
\newcommand{\xRightarrow}[2][]{\ext@arrow 0359\Rightarrowfill@{#1}{#2}}
\makeatother
\pgfplotsset{compat=newest}
\pgfplotsset{plot coordinates/math parser=false}
\newlength\figureheight
\newlength\figurewidth

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
	\vspace{5cm}
	\huge{\textbf{\hmwkClass}}\\
	\vspace{9pt}
	\LARGE{\hmwkTitle}\\
	\vspace{7cm}
}

\author{\textbf{\hmwkAuthorName\ - \hmwkAuthorAEM}
		\vspace{0.5em}\\
		\textbf{Ιακωβίδης Γρηγόριος\ - 7686}
		\vspace{0.5em}\\
		\textbf{Αμουτζιάς Αθανάσιος\ - 7619}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

	\maketitle

	%----------------------------------------------------------------------------------------
	%	TABLE OF CONTENTS
	%----------------------------------------------------------------------------------------

	%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

	%\newpage
%	\tableofcontents
%	\clearpage
	%\newpage


	%----------------------------------------------------------------------------------------
	%	Document
	%----------------------------------------------------------------------------------------
	\section{Γενικά}
	Καλούμαστε να υλοποιήσουμε κατανεμημένο αλγόριθμο σε CUDA που να επιλύει το πρόβλημα \textit{All Pair Shortest Path (APSP)} με τη χρήση του αλγορίθμου \textit{Warshall-Floyd}. Ουσιαστικά έχουμε ένα κατευθυνόμενο γράφο $G(V, E)$ με $V, E$ τα σύνολα των κόμβων και των ακμών αντίστοιχα, και θέλουμε να βρούμε την ελάχιστη απόσταση μεταξύ δύο κόμβων $v_i, v_j,\ \forall i,j \in V$. Η διαφορά με την προηγούμενη εργασία είναι ότι δοκίμαζουμε διαφορετικές τοπολογίες μνήμης και νημάτων προκειμένου να έχουμε aligned τα στοιχεία στη μνήμη, και να έχουμε coalesced το memory acceess, προσφέροντας μας καλύτερους χρόνους προσπέλασης. Ορίζουμε λοιπόν το ακόλουθο project structure, όπως και προηγουμένως:\\

	\begin{wrapfigure}{r}{0.4\textwidth}
		\begin{minipage}[t]{0.4\textwidth}
			\dirtree{%
				.1 trunk/.
				.2 bin/.
				.3 apsp\_coalesced.
				.2 build/.
				.3 apsp.o.
				.2 include/.
				.3 apsp\_coalesced.h.
				.2 src/.
				.3 apsp\_coalesced.cu.
				.2 bench.rb.
			    .2 makefile.
			    .2 plotmake.m.
				.2 results.csv.
			}
		\end{minipage}
		\caption{Project Structure}
	\end{wrapfigure}

	Στον φάκελο \verb|bin/| έχουμε το εκτελέσιμο αρχείο \verb|apsp| το οποίο δέχεται 3 ορίσματα: $v, p, w$ και αφού δημιουργήσει τον τετραγωνικό πίνακα γειτνίασης $W$ $2^{2v}$ στοιχείων του γράφου $G$ \footnote{Η δημιουργία του πίνακα γειτνίασης ενσωματώθηκε μέσα στο πρόγραμμα μας για μεγαλύτερη ευκολία εκτέλεσης των πειραμάτων} και μετά εκτελεί τον αλγόριθμο \textit{Warshall-Floyd} στο γράφο αυτό για να βρει το επιθυμητό αποτέλεσμα. Ο αλγόριθμος εκτελείται σειριακά και παράλληλα με τη χρήση CUDA με διαφορετικές παράλληλες τοπολογίες και τα αποτελέσματα συγκρίνονται στο τέλος. Στον κατάλογο  \verb|build/| βρίσκονται τα compiled object files από το κάθε αρχείο, τα οποία γίνονται αργότερα link μεταξύ τους και των βιβλιοθηκών του συστήματος για να παράξουν το εκτελέσιμο \verb|apsp_coalesced|. Στο φάκελο \verb|include/| βρίσκονται τα header files για το κάθε αρχείο κώδικα,  τα οποία αρχεία βρίσκονται στο directory \verb|src/|.\\

	Επιπλέον υπάρχουν τα αρχεία \verb|bench.rb|, \verb|makefile|, \verb|plotmake.m|, \verb|results.csv|, από τα οποία το πρώτο αποτελεί ένα Ruby script το οποίο εκτελεί το πρόγραμμα \verb|apsp| για όλους τους πιθανούς συνδυασμούς των $n, p$ και καταγράφει τα αποτελέσματα στο CSV αρχείο \verb|results.csv|. Το \verb|plotmake.m| είναι ένα MATLAB script το οποίο δημιουργεί τα διαγράμματα που υπάρχουν παρακάτω με τα δεδομένα του \verb|results.csv|. Το αρχείο \verb|makefile| περιέχει οδηγίες για την εντολή \verb|make|, ώστε να γίνεται compile και link εύκολα όλο το πρόγραμμα, καθώς αποτελείται από πολλά αρχεία κατανεμημένα σε διάφορους φακέλους.\\

	Τέλος, να σημειωθεί ότι χρησιμοποιήθηκε η έκδοση 4.1.2 του \verb|gcc| με optimization level \verb|-O3| και η έκδοση 5.5.0 των \verb|CUDA Compilation Tools| με αρχιτεκτονική \verb|sm_13|.

\section{Υλοποίηση σε CUDA}
	Έχουμε τον πίνακα γειτνίασης $W$ διαστάσεων $n\times n$. Ορίζουμε πως το κάθε block θα περιέχει 256 νήματα, οπότε  καθορίζουμε το μέγεθος του grid ανάλογα με το μέγεθος του προβλήματος. Ο γενικός τύπος υπολογισμού του στοιχείου $(i, j)$ του βέλτιστου πίνακα $W'$ δίνεται από
	$$
		W'(i, j) = \min\left\{W(i, j),\ W(i,k) + W(k,j)\right\},\quad \forall k \in [0, n)
	$$
	Χρησιμοποιούμε 3 διαφορετικές γενικές τοπολογίες νημάτων, και για κάθε μία από αυτές, υλοποιούμε 4 διαφορετικές μεθόδους παραλληλοποιήσης. Στην πρώτη περίπτωση, έχουμε μια απλή τοπολογία τετραγώνου χωρίς να εκμεταλευτούμε κάποια ιδιότητα της αρχιτεκτονικής ή του αλγορίθμου. Στη δεύτερη περίπτωση, έχουμε πάλι τοπολογία τετραγώνου αλλά κάνουμε και χρήση του ανάστροφου πίνακα, οπότε πλέον έχουμε
	$$
		W'(i, j) = \min\left\{W(i, j),\ W^{\mathrm{T}}(k,i) + W(k,j)\right\},\quad \forall k \in [0, n)
	$$
	και η πρόσβασή μας στους πίνακες είναι μονάχα κατά γραμμές. Τέλος, στην τρίτη περίπτωση, στοιχίζουμε τα νήματα σε γραμμές ώστε να έχουμε πλήρως coalesced πρόσβαση στον πίνακα $W$, χωρίς τη χρήση ανάστροφου πίνακα.

\subsection{Τοπολογία τετραγώνου, χωρίς χρήση ανάστροφου}

\subsubsection{Ένα κελί ανά νήμα, χωρίς χρήση shared memory}
To κάθε block έχει 256 νήματα σε τοπολογία $16 \times 16$. Συνεπώς, ορίζουμε τετράγωνο grid διαστάσεων $\tfrac{n}{16}\times\tfrac{n}{16}$ και εκτελούμε $n$ φορές την kernel συνάρτηση σε $n^2$ νήματα ταυτόχρονα. Το κάθε νήμα ουσιαστικά αφού προσδιοριστεί στο χώρο και βρει πιο στοιχείο του βέλτιστου πίνακα $W'$ του αντιστοιχεί, το υπολογίζει σύμφωνα με το γενικό τύπο που δόθηκε παραπάνω σε κάθε μία από τις $n$ επαναλήψεις του kernel (το $k$ ουσιαστικά αποτελεί τον iterator). Έτσι σχηματίζεται ο πίνακας των ελάχιστων αποστάσεων.

\subsubsection{Ένα κελί ανά νήμα, με χρήση shared memory}
To kernel function παραμένει ως έχει με τη μόνη διαφορά ότι πλέον μπορούμε να εκμεταλευτούμε τη shared memory, τουλάχιστον στο βαθμό που μας επιτρέπει η τοπολογία τετραγώνου. Για κάθε $k$, το κάθε block θα έχει κοινή την $k$-οστή γραμμή του πίνακα, οπότε ορίζουμε πως αυτή η γραμμή θα ανήκει στην shared memory του κάθε thread block. \footnote{Είναι εφικτό να έχουμε και τις στήλες στο shared memory, αλλά τα πειραματικά δεδομένα απέδειξαν ότι δεν βοηθάει την επίδοση του προγράμματος, αντιθέτως μάλιστα είχαμε μεγαλύτερους χρόνους εκτέλεσης.}

\subsubsection{Δύο κελιά ανά νήμα, με χρήση shared memory}
Η λογική της υλοποίησης παραμένει ακριβώς ίδια με πριν, μόνο που πλέον το κάθε thread έχει grain 2 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{32}\times\tfrac{n}{16}$. Πλέον το κάθε νήμα θα δουλεύει πάνω στο στοιχείο $(i, j)$ αλλά και στο $(i + \tfrac{n}{2}, j)$ του πίνακα $W$, οπότε το κάθε block θα έχει κοινή την $k$-οστή καθώς και την $(k+\tfrac{n}{2})$-οστή γραμμή.

%Επίσης, μόνο για την ειδική περίπτωση όπου $n = 2^7$, ορίζουμε των αριθμό των στηλών του πλέγματος 1 αντί για 0 που θα ήτανε κανονικά, και έτσι το grid είναι διαστάσεων $1\times 64$, κάνοντας έτσι τα μισά threads να τερματίζουν αμέσως καθώς αναφέρονται σε στοιχεία εκτός πίνακα.

\subsubsection{Τέσσερα κελιά ανά νήμα, με χρήση shared memory}
Ακολουθώντας την ίδια λογική, έχουμε το κάθε thread να έχει grain 4 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{64}\times\tfrac{n}{16}$. Πλέον το κάθε νήμα θα δουλεύει στα στοιχεία $\left(i, j\right)$, $\left(i + \tfrac{n}{4}, j\right)$, $\left(i + \tfrac{2n}{4}, j\right)$ και $\left(i + \tfrac{3n}{4}, j\right)$. Επομένως, στην shared memory κάθε block θα έχουμε τις γραμμές $k,\ k + \tfrac{n}{4},\ k + \tfrac{2n}{4},\ k + \tfrac{3n}{4}$.

%Επίσης, όπως και προηγουμένως, μόνο για την ειδική περίπτωση όπου $n = 2^7$, ορίζουμε των αριθμό των στηλών του πλέγματος 1 αντί για 0 που θα ήτανε κανονικά, και έτσι το grid είναι διαστάσεων $1\times 32$, κάνοντας έτσι τα μισά threads να τερματίζουν αμέσως καθώς αναφέρονται σε στοιχεία εκτός πίνακα.

\subsection{Τοπολογία τετραγώνου, με χρήση ανάστροφου}

\subsubsection{Ένα κελί ανά νήμα, χωρίς χρήση shared memory}
ΌΠως και πριν τo κάθε block έχει 256 νήματα σε τοπολογία $16 \times 16$, με τη μόνη διαφορά ότι πλέον στη μνήμη της κάρτας έχουμε και τον ανάστροφο πίνακα $W^\mathrm{T}$, οπότε η πρόσβαση στη μνήμη είναι πάντα κατά γραμμές. Συνεπώς, ορίζουμε τετράγωνο grid διαστάσεων $\tfrac{n}{16}\times\tfrac{n}{16}$ και εκτελούμε $n$ φορές την kernel συνάρτηση σε $n^2$ νήματα ταυτόχρονα. Το κάθε νήμα ουσιαστικά αφού προσδιοριστεί στο χώρο και βρει πιο στοιχείο του βέλτιστου πίνακα $W'$ του αντιστοιχεί, το υπολογίζει σύμφωνα με
$$
	W'(i, j) = \min\left\{W(i, j),\ W^{\mathrm{T}}(k,i) + W(k,j)\right\},\quad k \in [0, n)
$$
σε κάθε μία από τις $n$ επαναλήψεις του kernel (το $k$ ουσιαστικά αποτελεί τον iterator). Έτσι σχηματίζεται ο πίνακας των ελάχιστων αποστάσεων $W'$.

\subsubsection{Ένα κελί ανά νήμα, με χρήση shared memory}
To kernel function παραμένει ως έχει με τη μόνη διαφορά ότι πλέον μπορούμε να εκμεταλευτούμε τη shared memory, τουλάχιστον στο βαθμό που μας επιτρέπει η τοπολογία τετραγώνου. Για κάθε $k$, το κάθε block θα έχει κοινή την $k$-οστή γραμμή του πίνακα, οπότε ορίζουμε πως αυτή η γραμμή θα ανήκει στην shared memory του κάθε thread block, απλά πλέον όπως και πριν η προσβασή στους πίνακες είναι μόνο κατά γραμμές, οπότε έχουμε coalescence στο memory access.

\subsubsection{Δύο κελιά ανά νήμα, με χρήση shared memory}
Η λογική της υλοποίησης παραμένει ακριβώς ίδια με πριν, μόνο που πλέον το κάθε thread έχει grain 2 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{32}\times\tfrac{n}{16}$. Πλέον το κάθε νήμα θα δουλεύει πάνω στο στοιχείο $(i, j)$ αλλά και στο $(i + \tfrac{n}{2}, j)$ του πίνακα $W$, οπότε το κάθε block θα έχει κοινή την $k$-οστή καθώς και την $(k+\tfrac{n}{2})$-οστή γραμμή, απλά πλέον όπως και πριν η προσβασή στους πίνακες είναι μόνο κατά γραμμές, οπότε έχουμε coalescence στο memory access.

\subsubsection{Τέσσερα κελιά ανά νήμα, με χρήση shared memory}
Ακολουθώντας την ίδια λογική, έχουμε το κάθε thread να έχει grain 4 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{64}\times\tfrac{n}{16}$. Πλέον το κάθε νήμα θα δουλεύει στα στοιχεία $\left(i, j\right)$, $\left(i + \tfrac{n}{4}, j\right)$, $\left(i + \tfrac{2n}{4}, j\right)$ και $\left(i + \tfrac{3n}{4}, j\right)$. Επομένως, στην shared memory κάθε block θα έχουμε τις γραμμές $k,\ k + \tfrac{n}{4},\ k + \tfrac{2n}{4},\ k + \tfrac{3n}{4}$, απλά πλέον όπως και πριν η προσβασή στους πίνακες είναι μόνο κατά γραμμές, οπότε έχουμε coalescence στο memory access.

\subsection{Τοπολογία γραμμής}
\subsubsection{Ένα κελί ανά νήμα, χωρίς χρήση shared memory}
Εδώ πλέον αλλάζει δραστικά η τοπολογία μας, συνεπώς ο προσδιορισμός του κάθε νήματος στο χώρο είναι ελαφρώς διαφορετικός. Πιο συγκεκριμένα, έχουμε πάλι 256 νήματα ανά block, αλλά αυτή τη φορά είναι σε μία διάσταση, έχοντας έτσι 256 νήματα σε σειρά. Οι διαστάσεις του grid προκύπτουν $\tfrac{n}{256}\times n$,   ώστε να πετύχουμε coalescence στην πρόσβαση των δεδομένων. \footnote{Ορίζουμε τις διαστάσεις του πλέγματος έτσι ώστε να μην ξεπεράσουμε ποτέ το $2^{16}$, το οποίο είναι ο μέγιστος αριθμός block ενός grid ανά διάσταση} Έτσι ουσιαστικά αναθέτουμε κάθε γραμμή του πίνακα σε ένα thread block. Να σημειωθεί ότι, λόγω του γεγονότος ότι έχουμε ορίσει κάθε block να περιέχει 256 νήματα, για $n = 2^7$, ο αριθμός των στηλών του grid θα προκύψει 0, πράγμα δεν υφίσταται, οπότε σε αυτή μόνο την περίπτωση το θέτουμε 1 και έτσι το πλέγμα είναι διαστάσεων $1\times 128$, πράγμα το οποίο θα κάνει τα μισά thread που θα κληθούν να τερματίσουν αμέσως, καθώς θα αναφέρονται σε στοιχεία εκτός του πίνακα.

%και η κοινή μνήμη του κάθε block θα έχει τα ίδια στοιχεία για το κάθε νήμα.

\subsubsection{Ένα κελί ανά νήμα, με χρήση shared memory}
Το kernel function παραμένει σχεδόν ως έχει, μόνο που πλέον δεδομένης της τοπολογίας μπορούμε να εκμεταλευτούμε την shared memory σε μεγάλο βαθμό, καθώς πλέον στοιχίζοντας τα threads μας σε γραμμή το κάθε block θα έχει κοινό ένα σημείο για κάθε διαφορετικό $k$, αντί μιας ολόκληρης γραμμής, το οποίο θα σήμαινε πρόσβαση σε διαφορετικές στήλες. Επιπλέον, όπως και πριν, για την ειδική περίπτωση όπου $n=2^7$, ορίζουμε των αριθμό των στηλών του πλέγματος 1 αντί για 0 που θα ήτανε κανονικά, και έτσι το grid είναι διαστάσεων $1\times 128$, κάνοντας έτσι τα μισά threads να τερματίζουν αμέσως καθώς αναφέρονται σε στοιχεία εκτός πίνακα.

\subsubsection{Δύο κελιά ανά νήμα, με χρήση shared memory}
Η λογική της υλοποίησης παραμένει ακριβώς ίδια με πριν, μόνο που πλέον το κάθε thread έχει grain 2 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{256}\times\tfrac{n}{2}$. Πλέον το κάθε νήμα θα δουλεύει πάνω στο στοιχείο $(i, j)$ αλλά και στο $(i + \tfrac{n}{2}, j)$ του πίνακα $W$. Επίσης, όπως και προηγουμένως, μόνο για την ειδική περίπτωση όπου $n = 2^7$, ορίζουμε των αριθμό των στηλών του πλέγματος 1 αντί για 0 που θα ήτανε κανονικά, και έτσι το grid είναι διαστάσεων $1\times 64$, κάνοντας έτσι τα μισά threads να τερματίζουν αμέσως καθώς αναφέρονται σε στοιχεία εκτός πίνακα.

\subsubsection{Τέσσερα κελιά ανά νήμα, με χρήση shared memory}
Ακολουθώντας την ίδια λογική, έχουμε το κάθε thread να έχει grain 4 στοιχείων, πράγμα που σημαίνει πως το grid μας θα έχει διαστάσεις $\tfrac{n}{256}\times\tfrac{n}{4}$. Πλέον το κάθε νήμα θα δουλεύει στα στοιχεία $\left(i, j\right)$, $\left(i + \tfrac{n}{4}, j\right)$, $\left(i + \tfrac{2n}{4}, j\right)$ και $\left(i + \tfrac{3n}{4}, j\right)$. Επίσης, όπως και προηγουμένως, μόνο για την ειδική περίπτωση όπου $n = 2^7$, ορίζουμε των αριθμό των στηλών του πλέγματος 1 αντί για 0 που θα ήτανε κανονικά, και έτσι το grid είναι διαστάσεων $1\times 32$, κάνοντας έτσι τα μισά threads να τερματίζουν αμέσως καθώς αναφέρονται σε στοιχεία εκτός πίνακα.

\section{Μετρήσεις}
	Όλες οι μετρήσεις έγιναν στον server \url{diades.ee.auth.gr}, ο οποίος διαθέτει 2 κάρτες γραφικών, μία \textit{GeForce GTX 480} και μια \textit{Quadro NVS 290}. Η τιμή του ορίσματος $w$ είναι πάντα 1, αλλά αυτό δεν έχει απολύτως καμία σημασία όσον αφορά το υπολογιστικό κόστος του προβλήματος. Επίσης, μιας και στη προηγούμενη εργασία αποδείξαμε ότι η τιμή του $p$ δεν παίζει ρόλο, τα διαγράμματα που παρουσιάζονται παρακάτω είναι όλα για μια ενδεικτική τιμή της πιθανότητας $p$ (0.45). Στο αρχείο \verb|results.csv|, υπάρχουν και τα αποτελέσματα των μετρήσεων και για διαφορετικές τιμές του $p$, αλλά μπορεί εύκολα κανείς να δει ότι τα νούμερα είναι τα ίδια. Έτσι λοιπόν, στα σχήματα \ref{fig:p1}, \ref{fig:p2}, \ref{fig:p3} παρουσιάζονται οι πορείες του αλγορίθμου συναρτήσει του $n$, για τις τρεις διαφορετικές τοπολογίες, με το κάθε γράφημα να περιλαμβάνει 4 μεθόδους παραλληλοποιήσης.\\

	Αρχικά παρατηρούμε, ότι ανεξαρτήτως τοπολογίας και μεθόδου παραλληλοποίησης, όσο αυξάνει το μέγεθος του προβλήματος, τόσο αυξάνει και η αποδοτικότητα του αλγορίθμου, πράγμα αναμενόμενο καθώς για μεγαλύτερο $n$ το ποσοστό του χρόνου που αφιερώνεται σε χρόνους αρχικοποίησης νημάτων και μεταφοράς δεδομένων από μνήμη σε μνήμη είναι όλο και μικρότερο σε σχέση με τον συνολικό χρόνο περάτωσης του αλγορίθμου. Για $n > 2^{11}$ παρατηρεί κανείς ότι η αποδοτικότητα του αλγορίθμου καταλήγει σε ένα πλατό και υφίσταται κορεσμό.\\

	Επίσης, παρατηρεί κανείς ότι οι διαφορές στην επιτάχυνση του αλγορίθμου μεταξύ πρώτης και δέυτερης τοπολογίας, είναι σχεδόν ίδιες, πράγμα το οποίο μπορεί εκ πρώτης όψεως να μην φαίνεται φυσιολογικό, αλλά στην πραγματικότητα είναι εφικτή η αιτιοόγησή του. Και στις δύο τοπολογίες υπενθυμίζουμε ότι τα νήματα μας είναι διατεγμένα σε τετράγωνο, με την διαφορά να υφίσταται στο γεγονός ότι στη δεύτερη περίπτωση κάνουμε χρήση του ανάστροφου πίνακα ώστε όταν πάμε να διαβάσουμε από διαφορετική στήλη να διαβάζουμε ουσιαστικά από την αντίστοιχη γραμμή του ανάστροφου, κρατόντας όλα τα reads μας ως γραμμές, ώστε να πετύχουμε μεγαλύτερο coalescence. Θεωρητικά αυτό ισχύει, αλλά στην πραγματικότητα πρέπει να λάβουμε υπ'όψιν το γεγονός ότι πρώτον, ναι μεν όλες μας οι αναγνώσεις είναι σε γραμμές, αλλά ο ανάστροφος δεν είναι στοιχισμένος με τον κανονικό οπότε χάνεται ένα μέρος της σειριακότητας της ανάγνωσης, και δεύτερον πλέον έχουμε μία παραπάνω εγγραφή, καθώς πρέπει να ανανεώνουμε και τον ανάστροφο πίνακα με τα νέα δεδομένα, και η εγγραφή αυτή, όντας non-coalesced, μειώνει την αποδοτικότητα του kernel. Αυτό θα μπορούσε να επιβεβαιωθεί και με τη χρήση του \textit{Nvidia Profiler}, όπου μπορεί κανείς να δει ότι στην δεύτερη τοπολογία έχουμε ναι μεν αυξημένο read efficiency σε σχέση με την πρώτη, αλλά έχουμε μειωμένο write efficiency, πράγμα που αντισταθμίζει το οποιοδήποτε κέρδος στην αποδοτικότητα. Βέβαια, όταν εφαρμόζουμε τοπολογία γραμμής, η αποδοτικότητα του αλγορίθμου αυξάνει εμφανώς, μιας και πλέον εκμεταλευόμαστε στο έπακρον τη γεωμετρία της αρχιτεκτονικής.\\

	Τέλος, παρατηρούμε ότι η χρήση της shared memory δεν αποτελεί πολύ καταλυτικό παράγοντα, μιας και οι εγγραφές και οι αναγνώσεις που κάνουμε στη global είναι αρκετά optimized ώστε να μην επιδέχονται ιδιαίτερες βελτιώσεις. Μάλιστα, όταν έχουμε τις τετραγωνικές τοπολογίες, για το ίδιο thread grain η χρήση της shared memory δυσχέραινει την επίδοση του προγράμματος, λόγω τυχόν overheads που εισάγονται για να κάνουμε χρήση της. Βέβαια, καθώς αυξάνει το thread grain αυξάνει και η αποδοτικότητα του άλγορίθμου, καθώς όταν το κάθε νήμα ασχολείται με πάνω από ένα στοιχείο εξαλείφονται χρόνοι initialization και χρόνοι προσπέλασης που θα υπήρχαν σε άλλες περιπτώσεις. Να σημειωθεί ότι για μεθόδους με thread grain 8 δεν παρουσιάστηκαν εμφανείς διαφορές σε σχέση με την περίπτωση του thread grain 4, οπότε και για αυτό το λόγο δε συμπεριλήφθηκαν στην αναφορά. Επιπλέον, για επαρκώς μεγάλο grain coarseness, το efficiency του αλγορίθμου αρχίζει να μειώνεται σε σχέση με μικρότερα grains, καθώς το overhead που γλιτώνουμε είναι εντέλει μικρότερο από τον επιπλέον χρόνο περάτωσης ενός νήματος.\\
\clearpage

\subsection{Γραφήματα}
	\setlength\figureheight{3.87cm}
	\setlength\figurewidth{14.7cm}

	\begin{figure}[h!]
		\centering
		\includegraphics{figure-1.tikz}
		\caption{Ποσοστιαία επιτάχυνση του αλγορίθμου συναρτήσει του $n$ για τοπολογία τετραγώνου, χωρίς χρήση ανάστροφου πίνακα}
		\label{fig:p1}
	\end{figure}
	\begin{figure}[h!]
		\centering
		\includegraphics{figure-2.tikz}
		\caption{Ποσοστιαία επιτάχυνση του αλγορίθμου συναρτήσει του $n$ για τοπολογία τετραγώνου, με χρήση ανάστροφου πίνακα}
		\label{fig:p2}
	\end{figure}
	\begin{figure}[h!]
		\centering
		\includegraphics{figure-3.tikz}
		\caption{Ποσοστιαία επιτάχυνση του αλγορίθμου συναρτήσει του $n$ για τοπολογία γραμμής}
		\label{fig:p3}
	\end{figure}

\end{document}
